import GeminiService from '../scripts/gemini-service.js';import fs from 'fs';describe('GeminiService', () => {  let service;  beforeEach(() => {    process.env.GEMINI_API_KEY = 'test-key';        service = new GeminiService({      enableCaching: true,      cacheDir: '.context-cache/test-cache',      rateLimitPerHour: 5,      retryAttempts: 2,      retryDelay: 100,      timeout: 1000    });  });  afterEach(() => {    if (fs.existsSync('.context-cache/test-cache')) {      fs.rmSync('.context-cache/test-cache', { recursive: true, force: true });    }  });  describe('configuration', () => {    it('should use default configuration', () => {      const defaultService = new GeminiService();            expect(defaultService.config.model).toBe('gemini-3-flash-preview');      expect(defaultService.config.temperature).toBe(0.3);      expect(defaultService.config.maxOutputTokens).toBe(8096);    });    it('should use custom configuration', () => {      const customService = new GeminiService({        model: 'custom-model',        temperature: 0.7,        maxOutputTokens: 4000      });            expect(customService.config.model).toBe('custom-model');      expect(customService.config.temperature).toBe(0.7);      expect(customService.config.maxOutputTokens).toBe(4000);    });  });  describe('rate limiting', () => {    it('should track rate limit status', () => {      const status = service.getRateLimitStatus();            expect(status).toHaveProperty('callsInLastHour');      expect(status).toHaveProperty('limit');      expect(status).toHaveProperty('remaining');      expect(status).toHaveProperty('totalCalls');      expect(status.limit).toBe(5);    });    it('should record calls', () => {      service.recordCall();      service.recordCall();            const status = service.getRateLimitStatus();      expect(status.callsInLastHour).toBe(2);      expect(status.totalCalls).toBe(2);    });    it('should reset rate limit after time window', () => {      service.callHistory = [Date.now() - (61 * 60 * 1000)];            const status = service.getRateLimitStatus();      expect(status.callsInLastHour).toBe(0);    });  });  describe('caching', () => {    it('should create cache directory', () => {      expect(fs.existsSync('.context-cache/test-cache')).toBe(true);    });    it('should cache and retrieve responses', () => {      const prompt = 'Test prompt';      const response = 'Test response';            service.cacheResponse(prompt, response);      const cached = service.getCachedResponse(prompt);            expect(cached).toBe(response);    });    it('should return null for non-existent cache', () => {      const cached = service.getCachedResponse('nonexistent prompt');      expect(cached).toBeNull();    });    it('should have cache statistics', () => {      service.cacheResponse('Prompt 1', 'Response 1');      service.cacheResponse('Prompt 2', 'Response 2');      const stats = service.getCacheStats();      expect(stats.entries).toBe(2);      expect(stats.sizeBytes).toBeGreaterThan(0);    });    it('should clear cache', () => {      service.cacheResponse('Prompt 1', 'Response 1');      service.clearCache();      const stats = service.getCacheStats();      expect(stats.entries).toBe(0);    });    it('should invalidate old cache', () => {      const prompt = 'Test prompt';      service.cacheResponse(prompt, 'Old response');            const hash = service.hashPrompt(prompt);      const cachePath = `.context-cache/test-cache/${hash}.json`;      const cached = JSON.parse(fs.readFileSync(cachePath, 'utf8'));      cached.timestamp = Date.now() - (25 * 60 * 60 * 1000);      fs.writeFileSync(cachePath, JSON.stringify(cached));            const result = service.getCachedResponse(prompt);      expect(result).toBeNull();    });  });  describe('token optimization', () => {    it('should return short text as-is', () => {      const shortText = 'Short text';      const optimized = service.optimizePrompt(shortText, 100);            expect(optimized).toBe(shortText);    });    it('should optimize long prompts', () => {      const longText = 'a'.repeat(5000);      const optimized = service.optimizePrompt(longText, 100);            expect(optimized.length).toBeLessThan(longText.length);      expect(optimized).toContain('...');    });    it('should optimize at paragraph boundaries', () => {      const longText = 'First paragraph.\n\nSecond paragraph.\n\nThird paragraph with lots of text.';      const optimized = service.optimizePrompt(longText, 30);            expect(optimized).toContain('...');      expect(optimized.length).toBeLessThan(longText.length);    });  });  describe('error handling', () => {    it('should identify retryable errors', () => {      expect(service.isRetryableError(new Error('ETIMEDOUT'))).toBe(true);      expect(service.isRetryableError(new Error('429 rate limit'))).toBe(true);      expect(service.isRetryableError(new Error('500 server error'))).toBe(true);      expect(service.isRetryableError(new Error('503 unavailable'))).toBe(true);      expect(service.isRetryableError({ code: 'ECONNRESET' })).toBe(true);    });    it('should identify non-retryable errors', () => {      expect(service.isRetryableError(new Error('Invalid API key'))).toBe(false);      expect(service.isRetryableError(new Error('Bad request'))).toBe(false);    });  });  describe('utilities', () => {    it('should hash prompts consistently', () => {      const prompt = 'Test prompt';      const hash1 = service.hashPrompt(prompt);      const hash2 = service.hashPrompt(prompt);            expect(hash1).toBe(hash2);      expect(hash1).toHaveLength(16);    });    it('should hash different prompts differently', () => {      const hash1 = service.hashPrompt('Prompt 1');      const hash2 = service.hashPrompt('Prompt 2');            expect(hash1).not.toBe(hash2);    });    it('should sleep for specified duration', async () => {      const start = Date.now();      await service.sleep(100);      const elapsed = Date.now() - start;            expect(elapsed).toBeGreaterThanOrEqual(95);    });  });});